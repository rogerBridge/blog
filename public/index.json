[{"categories":[],"content":"我和源源 宝, 面基的时候, 当时感觉你好小一只, 好可爱, 当时感觉如果可以让你做我女朋友就好了, 宝, 我想和你之后的路一起走, 两个人互相陪伴的开心生活. ","date":"2022-07-04","objectID":"/%E6%88%91%E5%92%8C%E6%BA%90%E6%BA%90/:0:0","tags":[],"title":"我和源源","uri":"/%E6%88%91%E5%92%8C%E6%BA%90%E6%BA%90/"},{"categories":["GFW"],"content":"大概目标 v2ray最有意思的是它的可玩性比较好, 你可以自己组装模块, 就像拼积木一样, 下面我们通过一些配置文件的示例来说明它的一些模块的玩法: 注意: v2ray并不区分客户端和服务端, 你可以把它们通通想象为节点(node) 下面: 让我们来deploy一个现在比较基础的翻墙网络, 基本的流程图如下: 解释上图: node0 表示用户自己的设备, 比如: 手机(Android, iOS), 电脑(Windows, mac OS, Linux), 其他设备(openWRT), node1表示跳板设备, 关于为什么使用跳板设备, 据我的使用感受, 国内目前连接稳定且性价比较高的cn2-gia提供商只有腾讯轻量香港和阿里云轻量了, 但是直接将它们作为出口节点, 还是会有些不信任, 即使你使用了DOH, ISP 仍然可以获取你访问的IP, 然后反向推出你访问了什么网站, (因为各大云服务上其实都有一个自己的IP库, 这些是可以查找到的), 所有将node1指向node2, node2是一个国外的云服务提供商, 在购买之前, 可以使用node2服务商的测速页面, 在node1上进行测速, 一般香港的vps访问外界速度都是不错的, 然后就形成了一个基本的链式代理, 可能会有朋友面对一个问题, node2有时候google访问会经常出现captcha, 那么可以使用WARP, 一款由cloudflare提供的wireguard服务, 免费的哦, 就是一个基于wireguard的免费vpn, 这样可以规避google的captcha和netflix偶尔出现的ip封锁 😁 ","date":"2021-07-17","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/:1:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网01: 编写配置文件(writing)","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/"},{"categories":["GFW"],"content":"搭建一个网站 为了实现tls+websocket, 我们需要搭建一个网站, 比较通用的方法是: 使用nginx来处理tls, 并且将用户访问的url指向相应的代理服务器, 当然, 你也可以直接用go写一个http.ListenAndServeTLS(), 都是可以的, 但是毕竟前者更加通用嘛 : ) 一般的网络应用是这样搞的: nginx负责处理tls, load balance, reverse proxy, compress file, rate limit etc, 然后nginx后方代理一堆app; 为了伪装的像正常的上网流量, 并且是大流量, 一般建议代理一个网盘应用, 这里推荐cloudreve, 下面我们先搞一个cloudreve网站吧, 嘿嘿 ","date":"2021-07-17","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/:2:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网01: 编写配置文件(writing)","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/"},{"categories":["GFW"],"content":"搭建nginx-certbot 在你的node1中搭建, 有一个应用将nginx和certbot结合在了一起, 强烈推荐使用: nginx-certbot 这里是我稍微修改了一下下的docker-compose.yml, 主要是将nginx的版本更新到1.21.1, 将network_mode更新为: host version: '3' services: nginx: image: nginx:1.21.1 restart: unless-stopped volumes: - ./data/nginx:/etc/nginx/conf.d - ./data/certbot/conf:/etc/letsencrypt - ./data/certbot/www:/var/www/certbot network_mode: \"host\" command: \"/bin/sh -c 'while :; do sleep 6h \u0026 wait $${!}; nginx -s reload; done \u0026 nginx -g \\\"daemon off;\\\"'\" certbot: image: certbot/certbot restart: unless-stopped volumes: - ./data/certbot/conf:/etc/letsencrypt - ./data/certbot/www:/var/www/certbot entrypoint: \"/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h \u0026 wait $${!}; done;'\" 注意follow github的readme.md里面的指引, 为你的域名申请证书 然后执行: docker-compose up -d 这时候你的node1中就会出现两个container, 用docker ps即可查看 然后, 使用docker搭建cloudreve docker run -d \\ --name cloudreve \\ -e PUID=1000 \\ # optional -e PGID=1000 \\ # optional -e TZ=\"Asia/Shanghai\" \\ # optional -p 127.0.0.1:5212:5212 \\ --restart=unless-stopped \\ -v \u003cPATH TO uploads\u003e:/cloudreve/uploads \\ -v \u003cPATH TO config\u003e:/cloudreve/config \\ -v \u003cPATH TO db\u003e:/cloudreve/db \\ -v \u003cPATH TO avatar\u003e:/cloudreve/avatar \\ xavierniu/cloudreve # first time use, you need get password from docker logs -f cloudreve 之后, 在nginx-certbot文件夹中修改data/nginx/app.conf server { listen 443 ssl; server_name {yourdomain}; # 这里, 假如你的域名是: hello.com, 那你就填入: hello.com, 不要傻乎乎的填: {yourdomain}, 这就是一个参数而已 server_tokens off; ssl_certificate /etc/letsencrypt/live/{yourdomain}/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/{yourdomain}/privkey.pem; include /etc/letsencrypt/options-ssl-nginx.conf; ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; location / { client_max_body_size 128M; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://127.0.0.1:5212; # 这里就是你的cloudreve的本地地址 # 如果您要使用本地存储策略，请将下一行注释符删除，并更改大小为理论最大文件尺寸 # client_max_body_size 20000m; # root /etc/nginx/conf.d/html; # index index.html; # proxy_set_header Host $http_host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 然后, 试试访问: https://{yourdomain}/, 如果可以正常访问, 恭喜你, 第一步已经完成啦~ ","date":"2021-07-17","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/:2:1","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网01: 编写配置文件(writing)","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/"},{"categories":["GFW"],"content":"编写node0, node1, node2 的配置文件 node0是距离用户最近的节点, 一般来说, node0需要向用户提供一个本地的socks5和http代理服务器, 向外寻找node1的时候, 需要走tls+websocket协议, 实例配置文件如下: ","date":"2021-07-17","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/:3:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网01: 编写配置文件(writing)","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/"},{"categories":["GFW"],"content":"node0 log.json { \"log\": { \"loglevel\": \"warning\" } } dns.json { \"dns\": { \"hosts\": { \"geosite:category-ads-all\": \"127.0.0.1\", \"{yourdomain}\": \"{the IP address of your VPS}\" }, \"servers\": [ { \"address\": \"https://1.0.0.1/dns-query\", # send DoH request to VPS, if \"https+local://1.0.0.1/dns-query\", then send DoH request directly from localhost \"skipFallback\": true }, { \"address\": \"223.5.5.5\", \"domains\": [ \"geosite:cn\" ] }, { \"address\": \"119.29.29.29\", \"domains\": [ \"geosite:cn\" ] }, \"119.29.29.29\", \"localhost\" ] } } routing.json { \"routing\": { \"domainMatcher\": \"mph\", \"domainStrategy\": \"IPIfNonMatch\", # 其实我个人更加倾向AsIS \"rules\": [ // United States Proxy { \"type\": \"field\", \"inboundTag\": [\"socksUS\", \"httpUS\"], \"outboundTag\": \"direct\", \"ip\": [\"223.5.5.5\", \"119.29.29.29\", \"223.6.6.6\", \"geoip:private\", \"geoip:cn\"] }, { \"type\": \"field\", \"inboundTag\": [\"socksUS\", \"httpUS\"], \"outboundTag\": \"direct\", \"domain\": [ \"ext:mine.dat:direct\", \"geosite:cn\", \"geosite:category-games@cn\" ] }, { \"type\": \"field\", \"inboundTag\": [\"socksUS\", \"httpUS\"], \"outboundTag\": \"block\", \"domain\": [\"geosite:category-ads-all\", \"ext:mine.dat:block\"] }, { \"type\": \"field\", \"inboundTag\": [\"socksUS\", \"httpUS\"], \"outboundTag\": \"outboundUS\", \"network\": \"tcp,udp\" } ] } } inbounds.json { \"inbounds\": [ // United States { \"settings\": { \"udp\": true, \"auth\": \"noauth\", \"userLevel\": 0 }, \"listen\": \"0.0.0.0\", # 这里为什么使用0.0.0.0, 因为配置文件要被container使用, 如果用127.0.0.1的话, 本地映射不出来 \"protocol\": \"socks\", \"port\": 10830, \"sniffing\": { \"enabled\": true, \"destOverride\": [\"http\", \"tls\"] }, \"tag\": \"socksUS\" }, { \"settings\": { \"userLevel\": 0 }, \"listen\": \"0.0.0.0\", \"protocol\": \"http\", \"port\": 10831, \"tag\": \"httpUS\" } ] } outbound.json { \"outbounds\": [ { \"settings\": { \"vnext\": [ { \"address\": \"{yourdomain}\", \"users\": [ { \"id\": \"abcb3604-620a-4d84-ba0f-9274cf8c703a\", # 使用uuidgen生成一个就好 \"level\": 0, \"alterId\": 0, \"security\": \"auto\", \"email\": \"{username}@v2fly.org\" } ], \"port\": 443 } ] }, \"streamSettings\": { \"wsSettings\": { \"headers\": { \"Host\": \"\" }, \"path\": \"/0ON36ts1\" }, \"tlsSettings\": { \"serverName\": \"\", \"allowInsecure\": false }, \"network\": \"ws\", \"security\": \"tls\" }, \"protocol\": \"vmess\", \"tag\": \"outboundUS\" } ] } policy.json { \"policy\": { \"system\": { \"statsOutboundUplink\": true, \"statsOutboundDownlink\": true }, \"levels\": { \"8\": { \"handshake\": 4, \"connIdle\": 300, \"downlinkOnly\": 1, \"uplinkOnly\": 1 } } } } base.json { \"log\": {}, \"dns\": {}, \"stats\": {}, \"policy\": {}, \"transport\": {}, \"routing\": {}, \"inbounds\": [], \"outbounds\": [] } 然后, 将这些文件全部打包放入confDir文件夹, 至此, node0 的v2ray文件夹目录如下: node0 --asset(dir) # 用来放置路由文件, 推荐一个repository [v2ray-rules-dat](https://github.com/Loyalsoldier/v2ray-rules-dat) --confDir(dir) # 用来放置*.json文件 --env # environment variables file --run.sh # run v2ray node0 file env V2RAY_BUF_READV=enable V2RAY_CONF_GEOLOADER=memconservative run.sh #!/bin/bash # docker restart v2ray; # docker network create gfw --subnet=172.18.0.0/24 --gateway=172.18.0.1 docker run -d \\ --name v2ray \\ -v $PWD/confdir:/etc/v2ray/confdir \\ -v $PWD/asset:/usr/local/share/v2ray/ \\ --env-file=$PWD/env \\ --restart=unless-stopped \\ --network=gfw \\ --network-alias=v2ray \\ --ip=172.18.0.2 \\ v2fly/v2fly-core:v4.40.1 v2ray -confdir=/etc/v2ray/confdir ","date":"2021-07-17","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/:3:1","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网01: 编写配置文件(writing)","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9101/"},{"categories":["flash idea"],"content":"有个想法, 有没有可能知道一个区块链的公钥地址, 拿到它的私钥呢? 如果我把私钥加密, 用转账的形式, 给自己转账的时候添加一个备注信息, 备注信息就是加密后的私钥, 使用对称加密方法, 只需要我记的自己的密码就好, 那完整的流程就是: graph LR origin -- sha256 --\u003e bytesArray -- AES256GCM+message --\u003e encryptedBytes -- base64 --\u003e storeString 步骤如下: 首先, 设置一个自己的origin, origin就是你的密码; 然后, 使用SHA256SUM方法, 生成自己密码的摘要, []byte, 32个字节的长度; 然后, 使用AES256GCM的方法, 输入密码摘要和需要加密的字符串(也就是你的密钥或者助记词), 生成字节流, 为了便于肉眼查看和避免传输过程中包含特殊字符出现意外情况, 使用base64编码; 具体的执行代码在此: link 其实还可以使用gpg, 一个很好玩的工具, 先挖个坑, 以后填~ ","date":"2021-05-28","objectID":"/%E4%BF%9D%E5%AD%98secret-key%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["daydream"],"title":"保存secret key的想法","uri":"/%E4%BF%9D%E5%AD%98secret-key%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["GFW"],"content":"配置VPS","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":" 由于国内网络环境的影响, 获取一些国外技术资讯, 需要科学上网技术, 在此记录一下自己在这方面的学习历程吧 目前, 主流的科学上网方式有两种, 一种是加密, 一种是伪装 加密的方式, 稍微接触过一点科学上网的人, 应该都非常熟悉, 例如: vmess on v2ray 就是一种加密方式, 但是缺点是流量没有特征, 容易被 GFW 封禁. 为什么呢? 因为没有特征其实就是最大的特征, 什么人会用完全没有特征的流量呢? 不言自明~ 这系列博文, 介绍的科学上网方案, 具有以下特点: 外表是互联网上非常常见的协议, 内部实现为: tls+websocket+vmess, 外部特征为https长连接 可以在搭建翻墙方案时, 顺便搞一个反向代理, 自己写了其他测试应用, 直接丢到VPS, 通过web server来访问自己的测试应用, 因为web server 一般都套了一层tls, 省得为不同应用搞安全方案了 使用docker部署, 未来可能会改为docker compose, 方便在不同机器上进行部署 (可选) 如果你不信任自己的VPS提供商, 担心会被记录访问站点, 可以用第一层VPS做跳板, 跳转到第二层VPS 最好的方式其实是将自己藏匿于人群中, 你可以使用明面上的 https 流量, 域名指向你的网站, 但是, 接收到你的请求的 web 服务器会从你的请求 URL 中判断(URL 是不会被 GFW 查看到的, 例如: 你的网站是: mydomain.com, 请求 URL 是: /say, 那么这个/say 是不会被 GFW 查看到的, 可以知晓的仅仅是: mydomain.com, 为什么呢? 因为 client 在建立 TLS 连接的时候, 仅仅暴露了目标域名, 如果连目标域名都不想暴露的话, 就得使用 ESNI , 可惜, 国内目前不支持ESNI), 你到底是想要查看自己的网站, 还是想访问特定的 web app, web server 会根据你的 URL 来判断, 有疑惑的话, 随便抓一个https网站的包验证一下😂) 流程图如下: 过程如下: 本地设备与 Web 服务器建立 TLS 连接, Web 服务器通过查看设备的 URL, 将请求转发至不同的 App, App具体做什么由你控制, 比如说: 你可以设置: /free这个URL作为翻墙应用, /blog这个URL作为你的博客应用, /msg这个URL作为你的消息通知机器人应用(例如: telegram 中的一些API组合起来做消息机器人), / 这个URL作为你的主站点应用. ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:0:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"挑选VPS 首先, 你需要挑选一个好用的VPS, 如何判断VPS是否好用呢? 主要用以下几个工具判断: tcping traceroute mtr scp ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:1:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"tcping tcping是一款类似ping的工具, 不同的是: ping测试的是ICMP协议, 而tcping测试的是TCP协议 代码地址: tcping , 可以判断延迟 \u0026\u0026 特定端口是否被封 ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:1:1","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"traceroute traceroute可以查看数据包由本地设备发往目的设备的过程中, 经过的网关节点的延时 ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:1:2","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"mtr mtr是一款可以查看数据包在由本地设备发往目的设备的过程中, 查看丢包率等数据 ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:1:3","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"scp scp 是通过ssh协议传输文件的工具, 使用他, 你可以测试从VPS下载文件到本地的速度, 当然, 如果你是公网IP, 也可以测试从本地设备上传文件到VPS的速度, 不过现如今公网IP不多了吧, 所以… 上传测试的话, 还是用speedtest吧(注意通过代理访问) ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:1:4","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"部署VPS 然后, 就可以开始部署VPS啦 新的VPS到手, 激动的心情过后, 需要做的事情, 还是不少滴, 参考digitalocean的这篇文章: Initial server setup ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:2:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"添加新用户 绝大多数情况下, 不建议直接使用root用户来操作, 而是使用处在sudo用户组中的用户来操作 # 首先, 切换到root user # 之后就会开始提醒你, 输入新密码啦 sudo passwd root # 创建一个新的用户, username设置一个你想要设置的, for instance, `adduser clack` adduser clark # 中英文切换好麻烦, 用英文啦 # Add your new user to sudo user group usermod -aG sudo clark ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:2:1","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"使用SSH pubkey连接服务器 # 生成你的SSH key pair, 密钥在本地设备, 公钥复制到VPS的~/.ssh/authorized_keys 文件中, 博文中有一篇: \"ssh登录远程机器且不用密码\" 提到这个 # 生成结束后, 本地设备通过SSH连接VPS, 如果成功, 开始 # set /etc/ssh/sshd_config nano /etc/ssh/sshd_config # change below: # Protocol 2 # Port 22 端口一般情况下不要改 # MaxAuthTries 3 尝试失败次数最大限制为3次 # PermitRootLogin no 不允许root用户登录 # PubkeyAuthentication yes 允许pubkey方式登录 # PasswordAuthentication no 不允许密码登录 sudo systemctl restart sshd.service # 重启sshd服务 ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:2:2","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"设置UFW rules # setting up a basic firewall # show apps that ufw allowed sudo ufw app list # default deny incoming data sudo ufw default deny incoming # default allow outgoing data sudo ufw default allow outgoing # add what you want app that can pass the Firewall sudo ufw allow 22 sudo ufw allow 443 sudo ufw allow $what_you_want_port # 这里一般不用填, 因为我们可能都要走443端口了, 除非你有应用要直接和外网连接 ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:2:3","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"安装Docker环境 官方的Docker安装教程在此: Install Docker, 以Ubuntu环境为例: # 卸载旧版本Docker sudo apt-get remove docker docker-engine docker.io containerd runc # 添加 Repository sudo apt update; sudo apt install apt-transport-https ca-certificates curl gpg lsb-release # 添加官方gpg key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 添加官方源 echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null # 安装Docker sudo apt-get update; sudo apt-get install docker-ce docker-ce-cli containerd.io; # 将当前用户添加进入docker用户组, 让non-root用户可以执行docker命令 sudo usermod -aG docker $USER # 然后log out and log in 或者执行命令 newgrp docker # 为了检验non-root用户是否可以直接执行docker命令, 执行下列命令, 成功了会有提示 docker run hello-world ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:3:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["GFW"],"content":"总结 防火墙规则的添加和sshd_config的修改主要是为了VPS的安全性着想, 你实在是无法想象服务器每天要被探测多少次🤣(看一眼sshd.service的status和log会让你有所感触), 这只是最基本的防护手段, 还有一些监测系列, 以后再发吧. ","date":"2021-05-18","objectID":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/:4:0","tags":["v2ray","Linux"],"title":"V2ray从零开始实现科学上网00: 配置VPS","uri":"/v2ray%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%9100/"},{"categories":["Markdown","Typora"],"content":"记录Typora-Markdown学习历程","date":"2020-12-14","objectID":"/markdown-typora%E5%AD%A6%E4%B9%A0/","tags":["Markdown","Typora"],"title":"Markdown-Typora学习","uri":"/markdown-typora%E5%AD%A6%E4%B9%A0/"},{"categories":["Markdown","Typora"],"content":"Typora 常用快捷键 Ctrl1 到 Ctrl4 文章标题大小 Ctrl B 文本加粗 Ctrl I 文本斜体 Ctrl U 下划线 Shift Alt 5 删除线 Shift Ctrl ~ 行内代码块 Ctrl K 超链接, 比如我的博客 Ctrl T 生成表格, 支持拖拽移动, 网页端表格复制 Name Age Height Leborn James 36 203 Kawhi Leonard 29 203 Chris Paul 38 185 Ctrl Shift Q 插入引用 这里是插入的内容, 嘤嘤嘤 Ctrl Shift I 插入图片 ","date":"2020-12-14","objectID":"/markdown-typora%E5%AD%A6%E4%B9%A0/:1:0","tags":["Markdown","Typora"],"title":"Markdown-Typora学习","uri":"/markdown-typora%E5%AD%A6%E4%B9%A0/"},{"categories":["Markdown","Typora"],"content":"Typora其他 引用 参考链接: Golang1 是一个静态编译型语言 上标下标 (a+b)*(a-b) = a^2^ + b^2^ 2H~2~ +O~2~ = 2H~2~O 高亮 Go语言的特点就是: ==简单明了== ","date":"2020-12-14","objectID":"/markdown-typora%E5%AD%A6%E4%B9%A0/:2:0","tags":["Markdown","Typora"],"title":"Markdown-Typora学习","uri":"/markdown-typora%E5%AD%A6%E4%B9%A0/"},{"categories":["Markdown","Typora"],"content":"流程图 Flowchart 学习站点: mermaid graph TB base(Go) --\u003e a(simple) base(Go) --\u003e b(static type) base(Go) --\u003e c(compiled) ","date":"2020-12-14","objectID":"/markdown-typora%E5%AD%A6%E4%B9%A0/:3:0","tags":["Markdown","Typora"],"title":"Markdown-Typora学习","uri":"/markdown-typora%E5%AD%A6%E4%B9%A0/"},{"categories":["Markdown","Typora"],"content":"参考链接 https://en.wikipedia.org/wiki/Go_(programming_language) ↩︎ ","date":"2020-12-14","objectID":"/markdown-typora%E5%AD%A6%E4%B9%A0/:4:0","tags":["Markdown","Typora"],"title":"Markdown-Typora学习","uri":"/markdown-typora%E5%AD%A6%E4%B9%A0/"},{"categories":[],"content":"在Linux环境下, 如何烧录ISO启动盘到一个USB设备上呢? # assume you are in sudo user group # assume your usb device is /dev/sdx umount /dev/sdx; # assume you want your USB file system is fat sudo mkfs.vfat /dev/sdx -I # start dd ISO to USB dd if='ISO file location' of=/dev/sdx bs=4M \u0026\u0026 sync; # wait it finish, bingo :) ","date":"2020-08-31","objectID":"/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%B6%E4%BD%9C%E5%90%AF%E5%8A%A8%E7%9B%98/:0:0","tags":[],"title":"Linux环境下制作启动盘","uri":"/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%B6%E4%BD%9C%E5%90%AF%E5%8A%A8%E7%9B%98/"},{"categories":["Linux"],"content":" 系统: Ubuntu 20.04 LTS 方法一: resolvconf, 这个包可以在每次启动的时候, 修改/etc/resolv.conf文件, 持久化用户的nameserver设置 sudo apt update sudo apt install resolvconf sudo nano /etc/resolvconf/resolv.conf.d/head # add nameserver 119.29.29.29 sudo systemctl restart resolvconf.service # Then logout and login ","date":"2020-06-16","objectID":"/%E8%AE%BE%E7%BD%AE%E6%8C%81%E4%B9%85%E7%9A%84dns%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":[],"title":"Linux下设置持久的DNS解析服务器","uri":"/%E8%AE%BE%E7%BD%AE%E6%8C%81%E4%B9%85%E7%9A%84dns%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["Linux"],"content":"登录远程服务器的方式之一","date":"2020-03-30","objectID":"/ssh%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8%E4%B8%94%E4%B8%8D%E7%94%A8%E5%AF%86%E7%A0%81/","tags":["SSH","Linux"],"title":"SSH登录Ubuntu Server的设置方式","uri":"/ssh%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8%E4%B8%94%E4%B8%8D%E7%94%A8%E5%AF%86%E7%A0%81/"},{"categories":["Linux"],"content":"首先, 创建一个公钥秘钥对 # type ecdsa -b(bit length) 521 bit # ECDSA 是一个较短bit产生高强度的公钥-私钥对的方式 ssh-keygen -t ecdsa -b 521 然后, 将生成的文件添加到远程机器的authorized_keys文件下 cat ~/.ssh/{{ name you generated }}.pub | ssh a@A 'cat \u003e\u003e .ssh/authorized_keys' 或者 ssh-copy-id -i [public key file path] [userName]@[hostAddress]:~/.ssh/ 配置完成后, SSH登录远程机器就不用输入密码啦, 直接可以使用SSH方式连接 ssh {{username}}@{{host}} -i {{privKey}} ","date":"2020-03-30","objectID":"/ssh%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8%E4%B8%94%E4%B8%8D%E7%94%A8%E5%AF%86%E7%A0%81/:0:0","tags":["SSH","Linux"],"title":"SSH登录Ubuntu Server的设置方式","uri":"/ssh%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%BA%E5%99%A8%E4%B8%94%E4%B8%8D%E7%94%A8%E5%AF%86%E7%A0%81/"},{"categories":["Linux"],"content":"遇到一个问题, 系统从hibernate状态中恢复后, systemd中的一个自定义服务, 不运行了, 解决办法是: 加入新的Target [Unit] Description=Run my scripts # After=suspend.target # 在suspend之后执行 After=hibernate.target # After=hybrid-sleep.target [Service] ExecStart=/some/path/run/yourScript [Install] WantedBy=default.target # 启动时引导至unit # WantedBy=suspend.target # suspend时引导至unit WantedBy=hibernate.target # WantedBy=hybrid-sleep.target ","date":"2020-03-30","objectID":"/%E7%B3%BB%E7%BB%9F%E4%BB%8E%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%AD%E6%81%A2%E5%A4%8D%E6%97%B6%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/:0:0","tags":[],"title":"系统从休眠状态中恢复时启动脚本","uri":"/%E7%B3%BB%E7%BB%9F%E4%BB%8E%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%AD%E6%81%A2%E5%A4%8D%E6%97%B6%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"},{"categories":["Common Knowledge"],"content":" 什么是死锁? 线程 a 和线程 b 互相持有对方想要的资源, 双方都在等待对方释放资源, 僵持不下; 操作一个对象, 必须需要对象锁, 如果线程 a 拥有资源 A 的 🔓, 线程 b 拥有资源 B 的 🔓, 当同时, 线程 a 和线程 b 想要操作被对方占用了对象 🔓 的资源, 就必须等待对方, 到天长地久… 什么是乐观锁? 什么是悲观 🔓? 乐观锁: 每次拿到数据之后不会上锁, 但是会在更新的时候根据版本号的区别, 判断以下别人有没有更新这个数据; 数据的更新都是有版本号标记的, 如果一个数据被两个线程更新, 线程 a 拿到的时候, 版本号是 1, 它对数据进行操作后, 版本号+1, 成为 2, 线程 b 拿到的时候, 版本号是 2, 它对数据进行操作后, 版本号+1, 还是 2, 那么线程 b 的操作就会被舍弃… 悲观锁: 每次拿到数据之后都会上锁(对共享资源上锁), 这样被人想要拿数据的时候就必须等待, 直到他用完资源, 把锁空出来; Go 中的多态和继承? 多态: 父类 Animal 和子类: Dog, 两者共同拥有一个方法, run(), 如果有一个函数可以接收这个 Animal, 那么就可以接收 Dog, 这时它运行传入对象的 run 方法, 可能调用 Animal 的 run 方法, 也可能调用 Dog 的 run 方法, 这个就叫做多态; Go 中多态的实现依赖 interface, 如果两个类都实现了 run 方法, 那么它们就实现了这个接口, 传入这个接口的函数就可以接收传入这两个类; 继承: Go 中, 一个类要使用其他类的方法 组合 Go 中的组合: type Person struct { Name string Age int } func (p *Person) Laugh() { log.Println(\"Hahahahaha :)\") } // 如果Person和Children都有Laugh(), 那么c.Laugh() 会优先使用Child的Laugh // 如果Children想要拿到Person的属性: Field, 那么就使用c.Person.Field type Children struct { *Person Height int } func main() { c := Children{\u0026{Name: \"leo2n\", Age: 26}, 180} c.Langh() } ","date":"2020-01-01","objectID":"/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/:0:0","tags":[],"title":"Common Knowledge","uri":"/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"}]